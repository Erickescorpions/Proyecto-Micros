CCS PCM C Compiler, Version 5.076, 2401               29-nov.-23 22:47

               Filename:   D:\Documents\semestre2024_1\Micros\Proyecto\Proyecto-Micros\src\proyecto.lst

               ROM used:   1735 words (21%)
                           Largest free fragment is 2048
               RAM used:   43 (12%) at main() level
                           92 (25%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   588
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   04C
002B:  MOVF   22,W
002C:  MOVWF  04
002D:  MOVF   23,W
002E:  MOVWF  77
002F:  MOVF   24,W
0030:  MOVWF  78
0031:  MOVF   25,W
0032:  MOVWF  79
0033:  MOVF   26,W
0034:  MOVWF  7A
0035:  MOVF   27,W
0036:  BSF    03.6
0037:  MOVWF  0D
0038:  BCF    03.6
0039:  MOVF   28,W
003A:  BSF    03.6
003B:  MOVWF  0F
003C:  BCF    03.6
003D:  MOVF   29,W
003E:  BSF    03.6
003F:  MOVWF  0C
0040:  BCF    03.6
0041:  MOVF   2A,W
0042:  BSF    03.6
0043:  MOVWF  0E
0044:  BCF    03.6
0045:  MOVF   20,W
0046:  MOVWF  0A
0047:  SWAPF  21,W
0048:  MOVWF  03
0049:  SWAPF  7F,F
004A:  SWAPF  7F,W
004B:  RETFIE
004C:  BCF    0A.3
004D:  BCF    0A.4
004E:  GOTO   093
.................... #include <16f877a.h>                      //Tipo de MicroControlador a utilizar  
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
004F:  BCF    0A.0
0050:  BCF    0A.1
0051:  BCF    0A.2
0052:  ADDWF  02,F
0053:  RETLW  74
0054:  RETLW  65
0055:  RETLW  6D
0056:  RETLW  70
0057:  RETLW  65
0058:  RETLW  72
0059:  RETLW  61
005A:  RETLW  74
005B:  RETLW  75
005C:  RETLW  72
005D:  RETLW  61
005E:  RETLW  00
005F:  BCF    0A.0
0060:  BCF    0A.1
0061:  BCF    0A.2
0062:  ADDWF  02,F
0063:  RETLW  6D
0064:  RETLW  6F
0065:  RETLW  74
0066:  RETLW  6F
0067:  RETLW  72
0068:  RETLW  20
0069:  RETLW  6F
006A:  RETLW  6E
006B:  RETLW  00
006C:  BCF    0A.0
006D:  BCF    0A.1
006E:  BCF    0A.2
006F:  ADDWF  02,F
0070:  RETLW  6D
0071:  RETLW  6F
0072:  RETLW  74
0073:  RETLW  6F
0074:  RETLW  72
0075:  RETLW  20
0076:  RETLW  6F
0077:  RETLW  66
0078:  RETLW  66
0079:  RETLW  00
007A:  BCF    0A.0
007B:  BCF    0A.1
007C:  BCF    0A.2
007D:  ADDWF  02,F
007E:  RETLW  6C
007F:  RETLW  65
0080:  RETLW  64
0081:  RETLW  73
0082:  RETLW  20
0083:  RETLW  6F
0084:  RETLW  6E
0085:  RETLW  00
0086:  BCF    0A.0
0087:  BCF    0A.1
0088:  BCF    0A.2
0089:  ADDWF  02,F
008A:  RETLW  6C
008B:  RETLW  65
008C:  RETLW  64
008D:  RETLW  73
008E:  RETLW  20
008F:  RETLW  6F
0090:  RETLW  66
0091:  RETLW  66
0092:  RETLW  00
*
00A7:  DATA D0,30
00A8:  DATA F2,30
00A9:  DATA A0,31
00AA:  DATA E1,36
00AB:  DATA E2,34
00AC:  DATA 61,39
00AD:  DATA A0,3A
00AE:  DATA 6E,10
00AF:  DATA E3,37
00B0:  DATA 6E,3A
00B1:  DATA F2,37
00B2:  DATA 6C,10
00B3:  DATA 70,39
00B4:  DATA E5,39
00B5:  DATA E9,37
00B6:  DATA EE,32
00B7:  DATA A0,32
00B8:  DATA 6C,10
00B9:  DATA E2,37
00BA:  DATA F4,37
00BB:  DATA 6E,17
00BC:  DATA 20,05
00BD:  DATA 0A,00
00BE:  DATA C3,3A
00BF:  DATA 61,37
00C0:  DATA E4,37
00C1:  DATA A0,3A
00C2:  DATA F4,34
00C3:  DATA EC,34
00C4:  DATA E3,32
00C5:  DATA A0,32
00C6:  DATA 6C,10
00C7:  DATA ED,37
00C8:  DATA E4,37
00C9:  DATA 20,3A
00CA:  DATA 65,39
00CB:  DATA ED,34
00CC:  DATA EE,30
00CD:  DATA 6C,16
00CE:  DATA A0,3A
00CF:  DATA F3,30
00D0:  DATA 72,10
00D1:  DATA 65,36
00D2:  DATA A0,31
00D3:  DATA EF,36
00D4:  DATA 61,37
00D5:  DATA E4,37
00D6:  DATA 3A,10
00D7:  DATA 27,38
00D8:  DATA F7,36
00D9:  DATA 3D,1C
00DA:  DATA B0,13
00DB:  DATA 0A,00
00DC:  DATA A0,21
00DD:  DATA EF,36
00DE:  DATA 61,37
00DF:  DATA E4,37
00E0:  DATA 20,3A
00E1:  DATA E5,36
00E2:  DATA F0,32
00E3:  DATA F2,30
00E4:  DATA F4,3A
00E5:  DATA F2,30
00E6:  DATA 20,05
00E7:  DATA 20,00
00E8:  DATA 20,2A
00E9:  DATA E5,36
00EA:  DATA F0,32
00EB:  DATA F2,30
00EC:  DATA F4,3A
00ED:  DATA F2,30
00EE:  DATA 3A,10
00EF:  DATA 0A,10
00F0:  DATA 00,01
00F1:  DATA A0,21
00F2:  DATA EF,36
00F3:  DATA 61,37
00F4:  DATA E4,37
00F5:  DATA 20,38
00F6:  DATA F7,36
00F7:  DATA 20,05
00F8:  DATA 20,00
00F9:  RETLW  20
00FA:  RETLW  53
00FB:  RETLW  65
00FC:  RETLW  F1
00FD:  RETLW  61
00FE:  RETLW  6C
00FF:  RETLW  20
0100:  RETLW  70
0101:  RETLW  77
0102:  RETLW  6D
0103:  RETLW  3A
0104:  RETLW  20
0105:  RETLW  0A
0106:  RETLW  20
0107:  RETLW  00
0108:  DATA A0,21
0109:  DATA EF,36
010A:  DATA 61,37
010B:  DATA E4,37
010C:  DATA A0,36
010D:  DATA 6F,3A
010E:  DATA 6F,39
010F:  DATA A0,37
0110:  DATA 6E,10
0111:  DATA 20,05
0112:  DATA 20,00
0113:  DATA A0,26
0114:  DATA 6F,3A
0115:  DATA 6F,39
0116:  DATA E5,39
0117:  DATA A0,32
0118:  DATA EE,31
0119:  DATA 65,37
011A:  DATA E4,34
011B:  DATA E4,37
011C:  DATA 73,10
011D:  DATA 0A,10
011E:  DATA 00,01
011F:  DATA A0,21
0120:  DATA EF,36
0121:  DATA 61,37
0122:  DATA E4,37
0123:  DATA A0,36
0124:  DATA 6F,3A
0125:  DATA 6F,39
0126:  DATA A0,37
0127:  DATA 66,33
0128:  DATA 20,10
0129:  DATA 0A,10
012A:  DATA 00,01
012B:  DATA A0,26
012C:  DATA 6F,3A
012D:  DATA 6F,39
012E:  DATA E5,39
012F:  DATA A0,30
0130:  DATA F0,30
0131:  DATA E7,30
0132:  DATA E4,37
0133:  DATA 73,10
0134:  DATA 0A,10
0135:  DATA 00,01
0136:  DATA A0,21
0137:  DATA EF,36
0138:  DATA 61,37
0139:  DATA E4,37
013A:  DATA 20,36
013B:  DATA 65,32
013C:  DATA 73,10
013D:  DATA 6F,37
013E:  DATA 20,10
013F:  DATA 0A,10
0140:  DATA 00,01
0141:  DATA 20,26
0142:  DATA 65,32
0143:  DATA 73,10
0144:  DATA 65,37
0145:  DATA E3,32
0146:  DATA 6E,32
0147:  DATA 69,32
0148:  DATA EF,39
0149:  DATA 20,05
014A:  DATA 20,00
014B:  DATA A0,21
014C:  DATA EF,36
014D:  DATA 61,37
014E:  DATA E4,37
014F:  DATA 20,36
0150:  DATA 65,32
0151:  DATA 73,10
0152:  DATA 6F,33
0153:  DATA 66,10
0154:  DATA 20,05
0155:  DATA 20,00
0156:  DATA 20,26
0157:  DATA 65,32
0158:  DATA 73,10
0159:  DATA 61,38
015A:  DATA E1,33
015B:  DATA 61,32
015C:  DATA EF,39
015D:  DATA 20,05
015E:  DATA 20,00
015F:  DATA A0,21
0160:  DATA EF,36
0161:  DATA 61,37
0162:  DATA E4,37
0163:  DATA 20,37
0164:  DATA 6F,10
0165:  DATA F2,32
0166:  DATA E3,37
0167:  DATA EE,37
0168:  DATA E3,34
0169:  DATA E4,37
016A:  DATA 20,10
016B:  DATA 0A,10
016C:  DATA 00,00
*
0216:  MOVF   0B,W
0217:  MOVWF  46
0218:  BCF    0B.7
0219:  BSF    03.5
021A:  BSF    03.6
021B:  BSF    0C.7
021C:  BSF    0C.0
021D:  NOP
021E:  NOP
021F:  BCF    03.5
0220:  BCF    03.6
0221:  BTFSC  46.7
0222:  BSF    0B.7
0223:  BSF    03.6
0224:  MOVF   0C,W
0225:  ANDLW  7F
0226:  BTFSC  03.2
0227:  GOTO   26C
0228:  BCF    03.6
0229:  MOVWF  46
022A:  BSF    03.6
022B:  MOVF   0D,W
022C:  BCF    03.6
022D:  MOVWF  47
022E:  BSF    03.6
022F:  MOVF   0F,W
0230:  BCF    03.6
0231:  MOVWF  48
0232:  MOVF   46,W
0233:  BTFSS  0C.4
0234:  GOTO   233
0235:  MOVWF  19
0236:  MOVF   47,W
0237:  BSF    03.6
0238:  MOVWF  0D
0239:  BCF    03.6
023A:  MOVF   48,W
023B:  BSF    03.6
023C:  MOVWF  0F
023D:  BCF    03.6
023E:  MOVF   0B,W
023F:  MOVWF  49
0240:  BCF    0B.7
0241:  BSF    03.5
0242:  BSF    03.6
0243:  BSF    0C.7
0244:  BSF    0C.0
0245:  NOP
0246:  NOP
0247:  BCF    03.5
0248:  BCF    03.6
0249:  BTFSC  49.7
024A:  BSF    0B.7
024B:  BSF    03.6
024C:  RLF    0C,W
024D:  RLF    0E,W
024E:  ANDLW  7F
024F:  BTFSC  03.2
0250:  GOTO   26C
0251:  BCF    03.6
0252:  MOVWF  46
0253:  BSF    03.6
0254:  MOVF   0D,W
0255:  BCF    03.6
0256:  MOVWF  47
0257:  BSF    03.6
0258:  MOVF   0F,W
0259:  BCF    03.6
025A:  MOVWF  48
025B:  MOVF   46,W
025C:  BTFSS  0C.4
025D:  GOTO   25C
025E:  MOVWF  19
025F:  MOVF   47,W
0260:  BSF    03.6
0261:  MOVWF  0D
0262:  BCF    03.6
0263:  MOVF   48,W
0264:  BSF    03.6
0265:  MOVWF  0F
0266:  INCF   0D,F
0267:  BTFSC  03.2
0268:  INCF   0F,F
0269:  BCF    03.6
026A:  GOTO   216
026B:  BSF    03.6
026C:  BCF    03.6
026D:  RETURN
*
0504:  MOVF   0B,W
0505:  MOVWF  46
0506:  BCF    0B.7
0507:  BSF    03.5
0508:  BSF    03.6
0509:  BSF    0C.7
050A:  BSF    0C.0
050B:  NOP
050C:  NOP
050D:  BCF    03.5
050E:  BCF    03.6
050F:  BTFSC  46.7
0510:  BSF    0B.7
0511:  BSF    03.6
0512:  MOVF   0C,W
0513:  ANDLW  7F
0514:  BTFSC  03.2
0515:  GOTO   558
0516:  BCF    03.6
0517:  MOVWF  46
0518:  BSF    03.6
0519:  MOVF   0D,W
051A:  BCF    03.6
051B:  MOVWF  47
051C:  BSF    03.6
051D:  MOVF   0F,W
051E:  BCF    03.6
051F:  MOVWF  48
0520:  MOVF   46,W
0521:  MOVWF  49
0522:  CALL   4D8
0523:  MOVF   47,W
0524:  BSF    03.6
0525:  MOVWF  0D
0526:  BCF    03.6
0527:  MOVF   48,W
0528:  BSF    03.6
0529:  MOVWF  0F
052A:  BCF    03.6
052B:  MOVF   0B,W
052C:  MOVWF  49
052D:  BCF    0B.7
052E:  BSF    03.5
052F:  BSF    03.6
0530:  BSF    0C.7
0531:  BSF    0C.0
0532:  NOP
0533:  NOP
0534:  BCF    03.5
0535:  BCF    03.6
0536:  BTFSC  49.7
0537:  BSF    0B.7
0538:  BSF    03.6
0539:  RLF    0C,W
053A:  RLF    0E,W
053B:  ANDLW  7F
053C:  BTFSC  03.2
053D:  GOTO   558
053E:  BCF    03.6
053F:  MOVWF  46
0540:  BSF    03.6
0541:  MOVF   0D,W
0542:  BCF    03.6
0543:  MOVWF  47
0544:  BSF    03.6
0545:  MOVF   0F,W
0546:  BCF    03.6
0547:  MOVWF  48
0548:  MOVF   46,W
0549:  MOVWF  49
054A:  CALL   4D8
054B:  MOVF   47,W
054C:  BSF    03.6
054D:  MOVWF  0D
054E:  BCF    03.6
054F:  MOVF   48,W
0550:  BSF    03.6
0551:  MOVWF  0F
0552:  INCF   0D,F
0553:  BTFSC  03.2
0554:  INCF   0F,F
0555:  BCF    03.6
0556:  GOTO   504
0557:  BSF    03.6
0558:  BCF    03.6
0559:  RETURN
055A:  MOVF   0B,W
055B:  MOVWF  46
055C:  BCF    0B.7
055D:  BSF    03.5
055E:  BSF    03.6
055F:  BSF    0C.7
0560:  BSF    0C.0
0561:  NOP
0562:  NOP
0563:  BCF    03.5
0564:  BCF    03.6
0565:  BTFSC  46.7
0566:  BSF    0B.7
0567:  BSF    03.6
0568:  MOVF   0C,F
0569:  BTFSC  03.2
056A:  GOTO   584
056B:  MOVF   0D,W
056C:  BCF    03.6
056D:  MOVWF  46
056E:  BSF    03.6
056F:  MOVF   0F,W
0570:  BCF    03.6
0571:  MOVWF  47
0572:  BSF    03.6
0573:  MOVF   0C,W
0574:  BCF    03.6
0575:  MOVWF  49
0576:  CALL   4D8
0577:  MOVF   46,W
0578:  BSF    03.6
0579:  MOVWF  0D
057A:  BCF    03.6
057B:  MOVF   47,W
057C:  BSF    03.6
057D:  MOVWF  0F
057E:  INCF   0D,F
057F:  BTFSC  03.2
0580:  INCF   0F,F
0581:  BCF    03.6
0582:  GOTO   55A
0583:  BSF    03.6
0584:  BCF    03.6
0585:  BCF    0A.3
0586:  BCF    0A.4
0587:  GOTO   6BE (RETURN)
....................  
.................... #list 
....................  
....................  
.................... #fuses HS,NOPROTECT,NOWDT,NOLVP 
.................... #device ADC=8 
.................... #use delay(clock=20000000)                //Frec. de Osc. 20Mhz  
*
016D:  MOVLW  4B
016E:  MOVWF  04
016F:  BCF    03.7
0170:  MOVF   00,W
0171:  BTFSC  03.2
0172:  GOTO   180
0173:  MOVLW  06
0174:  MOVWF  78
0175:  CLRF   77
0176:  DECFSZ 77,F
0177:  GOTO   176
0178:  DECFSZ 78,F
0179:  GOTO   175
017A:  MOVLW  7B
017B:  MOVWF  77
017C:  DECFSZ 77,F
017D:  GOTO   17C
017E:  DECFSZ 00,F
017F:  GOTO   173
0180:  RETURN
....................  
.................... // establecemos comunicacion serial rx y tx  
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
.................... #use I2C(MASTER, SDA=PIN_C4, SCL=PIN_C3, FAST) 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
038A:  MOVF   69,W
038B:  MOVWF  7A
038C:  MOVF   68,W
038D:  MOVWF  04
038E:  BCF    03.7
038F:  BTFSC  7A.0
0390:  BSF    03.7
0391:  MOVF   00,W
0392:  MOVWF  6C
0393:  MOVF   6B,W
0394:  MOVWF  7A
0395:  MOVF   6A,W
0396:  MOVWF  04
0397:  BCF    03.7
0398:  BTFSC  7A.0
0399:  BSF    03.7
039A:  MOVF   00,W
039B:  SUBWF  6C,W
039C:  BTFSS  03.2
039D:  GOTO   3B5
....................       if (*s1 == '\0') 
039E:  MOVF   69,W
039F:  MOVWF  7A
03A0:  MOVF   68,W
03A1:  MOVWF  04
03A2:  BCF    03.7
03A3:  BTFSC  7A.0
03A4:  BSF    03.7
03A5:  MOVF   00,F
03A6:  BTFSS  03.2
03A7:  GOTO   3AB
....................          return(0); 
03A8:  MOVLW  00
03A9:  MOVWF  78
03AA:  GOTO   3CD
03AB:  MOVF   69,W
03AC:  MOVWF  7A
03AD:  MOVF   68,W
03AE:  INCF   68,F
03AF:  BTFSC  03.2
03B0:  INCF   69,F
03B1:  INCF   6A,F
03B2:  BTFSC  03.2
03B3:  INCF   6B,F
03B4:  GOTO   38A
....................    return((*s1 < *s2) ? -1: 1); 
03B5:  MOVF   69,W
03B6:  MOVWF  7A
03B7:  MOVF   68,W
03B8:  MOVWF  04
03B9:  BCF    03.7
03BA:  BTFSC  69.0
03BB:  BSF    03.7
03BC:  MOVF   00,W
03BD:  MOVWF  6C
03BE:  MOVF   6B,W
03BF:  MOVWF  7A
03C0:  MOVF   6A,W
03C1:  MOVWF  04
03C2:  BCF    03.7
03C3:  BTFSC  6B.0
03C4:  BSF    03.7
03C5:  MOVF   00,W
03C6:  SUBWF  6C,W
03C7:  BTFSC  03.0
03C8:  GOTO   3CB
03C9:  MOVLW  FF
03CA:  GOTO   3CC
03CB:  MOVLW  01
03CC:  MOVWF  78
03CD:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0305:  MOVF   6F,W
0306:  MOVWF  73
0307:  MOVF   6E,W
0308:  MOVWF  72
0309:  MOVF   73,W
030A:  MOVWF  7A
030B:  MOVF   72,W
030C:  MOVWF  04
030D:  BCF    03.7
030E:  BTFSC  7A.0
030F:  BSF    03.7
0310:  MOVF   00,F
0311:  BTFSC  03.2
0312:  GOTO   342
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0313:  MOVF   71,W
0314:  MOVWF  75
0315:  MOVF   70,W
0316:  MOVWF  74
0317:  MOVF   75,W
0318:  MOVWF  7A
0319:  MOVF   74,W
031A:  MOVWF  04
031B:  BCF    03.7
031C:  BTFSC  7A.0
031D:  BSF    03.7
031E:  MOVF   00,F
031F:  BTFSC  03.2
0320:  GOTO   33E
....................          if (*sc1 == *sc2) 
0321:  MOVF   73,W
0322:  MOVWF  7A
0323:  MOVF   72,W
0324:  MOVWF  04
0325:  BCF    03.7
0326:  BTFSC  7A.0
0327:  BSF    03.7
0328:  MOVF   00,W
0329:  MOVWF  76
032A:  MOVF   75,W
032B:  MOVWF  7A
032C:  MOVF   74,W
032D:  MOVWF  04
032E:  BCF    03.7
032F:  BTFSC  7A.0
0330:  BSF    03.7
0331:  MOVF   00,W
0332:  SUBWF  76,W
0333:  BTFSS  03.2
0334:  GOTO   33A
....................             return(sc1); 
0335:  MOVF   72,W
0336:  MOVWF  78
0337:  MOVF   73,W
0338:  MOVWF  79
0339:  GOTO   345
033A:  INCF   74,F
033B:  BTFSC  03.2
033C:  INCF   75,F
033D:  GOTO   317
033E:  INCF   72,F
033F:  BTFSC  03.2
0340:  INCF   73,F
0341:  GOTO   309
....................    return(0); 
0342:  MOVLW  00
0343:  MOVWF  78
0344:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
029B:  MOVF   6F,W
029C:  MOVWF  73
029D:  MOVF   6E,W
029E:  MOVWF  72
029F:  MOVF   73,W
02A0:  MOVWF  7A
02A1:  MOVF   72,W
02A2:  MOVWF  04
02A3:  BCF    03.7
02A4:  BTFSC  7A.0
02A5:  BSF    03.7
02A6:  MOVF   00,F
02A7:  BTFSC  03.2
02A8:  GOTO   2E0
....................       for (sc2 = s2; ; sc2++) 
02A9:  MOVF   71,W
02AA:  MOVWF  75
02AB:  MOVF   70,W
02AC:  MOVWF  74
....................     if (*sc2 == '\0') 
02AD:  MOVF   75,W
02AE:  MOVWF  7A
02AF:  MOVF   74,W
02B0:  MOVWF  04
02B1:  BCF    03.7
02B2:  BTFSC  7A.0
02B3:  BSF    03.7
02B4:  MOVF   00,F
02B5:  BTFSS  03.2
02B6:  GOTO   2C4
....................        return(sc1 - s1); 
02B7:  MOVF   6E,W
02B8:  SUBWF  72,W
02B9:  MOVWF  77
02BA:  MOVF   73,W
02BB:  MOVWF  7A
02BC:  MOVF   6F,W
02BD:  BTFSS  03.0
02BE:  INCFSZ 6F,W
02BF:  SUBWF  7A,F
02C0:  MOVF   77,W
02C1:  MOVWF  78
02C2:  GOTO   2EB
02C3:  GOTO   2D8
....................          else if (*sc1 == *sc2) 
02C4:  MOVF   73,W
02C5:  MOVWF  7A
02C6:  MOVF   72,W
02C7:  MOVWF  04
02C8:  BCF    03.7
02C9:  BTFSC  7A.0
02CA:  BSF    03.7
02CB:  MOVF   00,W
02CC:  MOVWF  76
02CD:  MOVF   75,W
02CE:  MOVWF  7A
02CF:  MOVF   74,W
02D0:  MOVWF  04
02D1:  BCF    03.7
02D2:  BTFSC  7A.0
02D3:  BSF    03.7
02D4:  MOVF   00,W
02D5:  SUBWF  76,W
02D6:  BTFSC  03.2
....................             break; 
02D7:  GOTO   2DC
02D8:  INCF   74,F
02D9:  BTFSC  03.2
02DA:  INCF   75,F
02DB:  GOTO   2AD
02DC:  INCF   72,F
02DD:  BTFSC  03.2
02DE:  INCF   73,F
02DF:  GOTO   29F
....................    return(sc1 - s1); 
02E0:  MOVF   6E,W
02E1:  SUBWF  72,W
02E2:  MOVWF  77
02E3:  MOVF   73,W
02E4:  MOVWF  7A
02E5:  MOVF   6F,W
02E6:  BTFSS  03.0
02E7:  INCFSZ 6F,W
02E8:  SUBWF  7A,F
02E9:  MOVF   77,W
02EA:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0361:  MOVF   6F,W
0362:  MOVWF  71
0363:  MOVF   6E,W
0364:  MOVWF  70
0365:  MOVF   71,W
0366:  MOVWF  7A
0367:  MOVF   70,W
0368:  MOVWF  04
0369:  BCF    03.7
036A:  BTFSC  7A.0
036B:  BSF    03.7
036C:  MOVF   00,F
036D:  BTFSC  03.2
036E:  GOTO   373
036F:  INCF   70,F
0370:  BTFSC  03.2
0371:  INCF   71,F
0372:  GOTO   365
....................    return(sc - s); 
0373:  MOVF   6E,W
0374:  SUBWF  70,W
0375:  MOVWF  77
0376:  MOVF   71,W
0377:  MOVWF  7A
0378:  MOVF   6F,W
0379:  BTFSS  03.0
037A:  INCFSZ 6F,W
037B:  SUBWF  7A,F
037C:  MOVF   77,W
037D:  MOVWF  78
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
05B2:  BCF    03.5
05B3:  CLRF   2C
05B4:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
*
0285:  MOVF   66,W
0286:  IORWF  67,W
0287:  BTFSC  03.2
0288:  GOTO   28D
0289:  MOVF   67,W
028A:  MOVWF  7A
028B:  MOVF   66,W
028C:  GOTO   290
028D:  MOVF   2D,W
028E:  MOVWF  7A
028F:  MOVF   2C,W
0290:  MOVWF  6A
0291:  MOVF   7A,W
0292:  MOVWF  6B
....................    beg += strspn(beg, s2); 
0293:  MOVF   6B,W
0294:  MOVWF  6F
0295:  MOVF   6A,W
0296:  MOVWF  6E
0297:  MOVF   69,W
0298:  MOVWF  71
0299:  MOVF   68,W
029A:  MOVWF  70
*
02EB:  MOVF   78,W
02EC:  ADDWF  6A,F
02ED:  BTFSC  03.0
02EE:  INCF   6B,F
....................    if (*beg == '\0') 
02EF:  MOVF   6B,W
02F0:  MOVWF  7A
02F1:  MOVF   6A,W
02F2:  MOVWF  04
02F3:  BCF    03.7
02F4:  BTFSC  7A.0
02F5:  BSF    03.7
02F6:  MOVF   00,F
02F7:  BTFSS  03.2
02F8:  GOTO   2FD
....................       return(0); 
02F9:  MOVLW  00
02FA:  MOVWF  78
02FB:  MOVWF  79
02FC:  GOTO   389
....................        
....................    end = strpbrk(beg, s2); 
02FD:  MOVF   6B,W
02FE:  MOVWF  6F
02FF:  MOVF   6A,W
0300:  MOVWF  6E
0301:  MOVF   69,W
0302:  MOVWF  71
0303:  MOVF   68,W
0304:  MOVWF  70
*
0345:  MOVF   79,W
0346:  MOVWF  6D
0347:  MOVF   78,W
0348:  MOVWF  6C
....................    if (end != '\0') 
0349:  MOVF   6C,F
034A:  BTFSS  03.2
034B:  GOTO   34F
034C:  MOVF   6D,F
034D:  BTFSC  03.2
034E:  GOTO   35D
....................    { 
....................       *end = '\0'; 
034F:  MOVF   6C,W
0350:  MOVWF  04
0351:  BCF    03.7
0352:  BTFSC  6D.0
0353:  BSF    03.7
0354:  CLRF   00
....................       end++; 
0355:  INCF   6C,F
0356:  BTFSC  03.2
0357:  INCF   6D,F
....................       save = end; 
0358:  MOVF   6D,W
0359:  MOVWF  2D
035A:  MOVF   6C,W
035B:  MOVWF  2C
....................    } 
035C:  GOTO   385
....................    else 
....................       save = beg + strlen(beg); 
035D:  MOVF   6B,W
035E:  MOVWF  6F
035F:  MOVF   6A,W
0360:  MOVWF  6E
*
037E:  MOVF   78,W
037F:  ADDWF  6A,W
0380:  MOVWF  2C
0381:  MOVF   6B,W
0382:  MOVWF  2D
0383:  BTFSC  03.0
0384:  INCF   2D,F
....................     
....................    return(beg); 
0385:  MOVF   6A,W
0386:  MOVWF  78
0387:  MOVF   6B,W
0388:  MOVWF  79
0389:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
019C:  MOVLW  0F
019D:  BSF    03.5
019E:  ANDWF  08,W
019F:  IORLW  F0
01A0:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01A1:  BCF    03.5
01A2:  BSF    08.2
....................    delay_cycles(1); 
01A3:  NOP
....................    lcd_output_enable(1); 
01A4:  BSF    08.0
....................    delay_cycles(1); 
01A5:  NOP
....................    high = lcd_read_nibble(); 
01A6:  CALL   190
01A7:  MOVF   78,W
01A8:  MOVWF  51
....................        
....................    lcd_output_enable(0); 
01A9:  BCF    08.0
....................    delay_cycles(1); 
01AA:  NOP
....................    lcd_output_enable(1); 
01AB:  BSF    08.0
....................    delay_us(1); 
01AC:  GOTO   1AD
01AD:  GOTO   1AE
01AE:  NOP
....................    low = lcd_read_nibble(); 
01AF:  CALL   190
01B0:  MOVF   78,W
01B1:  MOVWF  50
....................        
....................    lcd_output_enable(0); 
01B2:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
01B3:  MOVLW  0F
01B4:  BSF    03.5
01B5:  ANDWF  08,W
01B6:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01B7:  BCF    03.5
01B8:  SWAPF  51,W
01B9:  MOVWF  77
01BA:  MOVLW  F0
01BB:  ANDWF  77,F
01BC:  MOVF   77,W
01BD:  IORWF  50,W
01BE:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0190:  MOVF   08,W
0191:  MOVWF  77
0192:  SWAPF  08,W
0193:  ANDLW  0F
0194:  MOVWF  78
....................   #endif 
0195:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0181:  SWAPF  51,W
0182:  ANDLW  F0
0183:  MOVWF  77
0184:  MOVLW  0F
0185:  ANDWF  08,W
0186:  IORWF  77,W
0187:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0188:  NOP
....................    lcd_output_enable(1); 
0189:  BSF    08.0
....................    delay_us(2); 
018A:  MOVLW  03
018B:  MOVWF  77
018C:  DECFSZ 77,F
018D:  GOTO   18C
....................    lcd_output_enable(0); 
018E:  BCF    08.0
018F:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0196:  BSF    03.5
0197:  BCF    08.0
....................    lcd_rs_tris(); 
0198:  BCF    08.1
....................    lcd_rw_tris(); 
0199:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
019A:  BCF    03.5
019B:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01BF:  MOVF   78,W
01C0:  MOVWF  50
01C1:  BTFSC  50.7
01C2:  GOTO   19C
....................    lcd_output_rs(address); 
01C3:  BTFSS  4E.0
01C4:  BCF    08.1
01C5:  BTFSC  4E.0
01C6:  BSF    08.1
....................    delay_cycles(1); 
01C7:  NOP
....................    lcd_output_rw(0); 
01C8:  BCF    08.2
....................    delay_cycles(1); 
01C9:  NOP
....................    lcd_output_enable(0); 
01CA:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
01CB:  SWAPF  4F,W
01CC:  MOVWF  50
01CD:  MOVLW  0F
01CE:  ANDWF  50,F
01CF:  MOVF   50,W
01D0:  MOVWF  51
01D1:  CALL   181
....................    lcd_send_nibble(n & 0xf); 
01D2:  MOVF   4F,W
01D3:  ANDLW  0F
01D4:  MOVWF  50
01D5:  MOVWF  51
01D6:  CALL   181
01D7:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01D8:  MOVLW  28
01D9:  MOVWF  47
01DA:  MOVLW  0C
01DB:  MOVWF  48
01DC:  MOVLW  01
01DD:  MOVWF  49
01DE:  MOVLW  06
01DF:  MOVWF  4A
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01E0:  BCF    08.0
....................    lcd_output_rs(0); 
01E1:  BCF    08.1
....................    lcd_output_rw(0); 
01E2:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
01E3:  MOVLW  0F
01E4:  BSF    03.5
01E5:  ANDWF  08,W
01E6:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
01E7:  BCF    08.0
....................    lcd_rs_tris(); 
01E8:  BCF    08.1
....................    lcd_rw_tris(); 
01E9:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
01EA:  MOVLW  0F
01EB:  BCF    03.5
01EC:  MOVWF  4B
01ED:  CALL   16D
....................    for(i=1;i<=3;++i) 
01EE:  MOVLW  01
01EF:  MOVWF  46
01F0:  MOVF   46,W
01F1:  SUBLW  03
01F2:  BTFSS  03.0
01F3:  GOTO   1FC
....................    { 
....................        lcd_send_nibble(3); 
01F4:  MOVLW  03
01F5:  MOVWF  51
01F6:  CALL   181
....................        delay_ms(5); 
01F7:  MOVLW  05
01F8:  MOVWF  4B
01F9:  CALL   16D
01FA:  INCF   46,F
01FB:  GOTO   1F0
....................    } 
....................     
....................    lcd_send_nibble(2); 
01FC:  MOVLW  02
01FD:  MOVWF  51
01FE:  CALL   181
....................    delay_ms(5); 
01FF:  MOVLW  05
0200:  MOVWF  4B
0201:  CALL   16D
....................    for(i=0;i<=3;++i) 
0202:  CLRF   46
0203:  MOVF   46,W
0204:  SUBLW  03
0205:  BTFSS  03.0
0206:  GOTO   213
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0207:  MOVLW  47
0208:  ADDWF  46,W
0209:  MOVWF  04
020A:  BCF    03.7
020B:  MOVF   00,W
020C:  MOVWF  4B
020D:  CLRF   4E
020E:  MOVF   4B,W
020F:  MOVWF  4F
0210:  CALL   196
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0211:  INCF   46,F
0212:  GOTO   203
0213:  BCF    0A.3
0214:  BCF    0A.4
0215:  GOTO   5B6 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
04C6:  DECFSZ 4B,W
04C7:  GOTO   4C9
04C8:  GOTO   4CC
....................       address=LCD_LINE_TWO; 
04C9:  MOVLW  40
04CA:  MOVWF  4C
04CB:  GOTO   4CD
....................    else 
....................       address=0; 
04CC:  CLRF   4C
....................       
....................    address+=x-1; 
04CD:  MOVLW  01
04CE:  SUBWF  4A,W
04CF:  ADDWF  4C,F
....................    lcd_send_byte(0,0x80|address); 
04D0:  MOVF   4C,W
04D1:  IORLW  80
04D2:  MOVWF  4D
04D3:  CLRF   4E
04D4:  MOVF   4D,W
04D5:  MOVWF  4F
04D6:  CALL   196
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
04D7:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
04D8:  MOVF   49,W
04D9:  XORLW  07
04DA:  BTFSC  03.2
04DB:  GOTO   4E6
04DC:  XORLW  0B
04DD:  BTFSC  03.2
04DE:  GOTO   4EB
04DF:  XORLW  06
04E0:  BTFSC  03.2
04E1:  GOTO   4F3
04E2:  XORLW  02
04E3:  BTFSC  03.2
04E4:  GOTO   4F9
04E5:  GOTO   4FE
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
04E6:  MOVLW  01
04E7:  MOVWF  4A
04E8:  MOVWF  4B
04E9:  CALL   4C6
04EA:  GOTO   503
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
04EB:  CLRF   4E
04EC:  MOVLW  01
04ED:  MOVWF  4F
04EE:  CALL   196
....................                      delay_ms(2); 
04EF:  MOVLW  02
04F0:  MOVWF  4B
04F1:  CALL   16D
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
04F2:  GOTO   503
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
04F3:  MOVLW  01
04F4:  MOVWF  4A
04F5:  MOVLW  02
04F6:  MOVWF  4B
04F7:  CALL   4C6
04F8:  GOTO   503
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
04F9:  CLRF   4E
04FA:  MOVLW  10
04FB:  MOVWF  4F
04FC:  CALL   196
04FD:  GOTO   503
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
04FE:  MOVLW  01
04FF:  MOVWF  4E
0500:  MOVF   49,W
0501:  MOVWF  4F
0502:  CALL   196
....................      #endif 
....................    } 
0503:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define BOTON_CAMBIO PIN_B0 
.................... #define TAM_COMANDO 10 
.................... // selector = 0 -> control mediante potenciometro 
.................... // selector = 1 -> control mediante terminal    
.................... int selector = 0; 
....................  
.................... #INT_EXT 
.................... void interrupcion_RB0() { 
....................    if(input(BOTON_CAMBIO)) { 
*
0093:  BSF    03.5
0094:  BSF    06.0
0095:  BCF    03.5
0096:  BTFSS  06.0
0097:  GOTO   09E
.................... //!      lcd_clear(); 
....................     
....................       if(selector == 1) { 
0098:  DECFSZ 32,W
0099:  GOTO   09C
....................          selector = 0; 
009A:  CLRF   32
....................       } 
009B:  GOTO   09E
....................       else { 
....................          selector = 1; 
009C:  MOVLW  01
009D:  MOVWF  32
....................       } 
....................    } 
....................     
....................    delay_us(10); 
009E:  MOVLW  10
009F:  MOVWF  77
00A0:  DECFSZ 77,F
00A1:  GOTO   0A0
00A2:  NOP
00A3:  BCF    0B.1
00A4:  BCF    0A.3
00A5:  BCF    0A.4
00A6:  GOTO   02B
.................... } 
....................  
.................... void ajustaPWM(int16 ciclo); 
.................... int leer_comando(char* comando); 
.................... int separar_comando(char* comando, char* porcentaje_pwm); 
....................  
.................... int main() 
*
0588:  MOVF   03,W
0589:  ANDLW  1F
058A:  MOVWF  03
058B:  MOVLW  81
058C:  BSF    03.5
058D:  MOVWF  19
058E:  MOVLW  A6
058F:  MOVWF  18
0590:  MOVLW  90
0591:  BCF    03.5
0592:  MOVWF  18
0593:  MOVLW  FF
0594:  MOVWF  2B
0595:  BSF    2B.3
0596:  MOVF   2B,W
0597:  BSF    03.5
0598:  MOVWF  07
0599:  BCF    03.5
059A:  BSF    2B.4
059B:  MOVF   2B,W
059C:  BSF    03.5
059D:  MOVWF  07
059E:  MOVLW  0C
059F:  MOVWF  13
05A0:  MOVLW  28
05A1:  BCF    03.5
05A2:  MOVWF  14
05A3:  BSF    03.5
05A4:  BCF    14.7
05A5:  BCF    14.6
05A6:  BCF    03.5
05A7:  CLRF   32
05A8:  CLRF   34
05A9:  CLRF   33
05AA:  BSF    03.5
05AB:  BSF    1F.0
05AC:  BSF    1F.1
05AD:  BSF    1F.2
05AE:  BCF    1F.3
05AF:  MOVLW  07
05B0:  MOVWF  1C
05B1:  BCF    03.7
.................... { 
....................    lcd_init();   
*
05B5:  GOTO   1D8
....................    int valorAD; 
....................    char comando[TAM_COMANDO]; // mensaje recibio: pwm=100] 
....................    char porcentaje_pwm[3] = "50"; 
05B6:  MOVLW  35
05B7:  MOVWF  40
05B8:  MOVLW  30
05B9:  MOVWF  41
05BA:  CLRF   42
....................    int recibio_comando = 0; 
05BB:  CLRF   43
....................  
....................    // habilitamos la interrupcion externa RB0 
....................    enable_interrupts(INT_EXT); 
05BC:  BSF    0B.4
....................    ext_int_edge(L_TO_H); 
05BD:  BSF    03.5
05BE:  BSF    01.6
....................    enable_interrupts(GLOBAL); 
05BF:  MOVLW  C0
05C0:  BCF    03.5
05C1:  IORWF  0B,F
....................  
....................    // lectura de porcentaje duty cicle mediante puerto analogico AN0 
....................    // establecemos puerto AN0 como analogico 
....................    setup_adc_ports(AN0);       
05C2:  BSF    03.5
05C3:  BCF    1F.0
05C4:  BSF    1F.1
05C5:  BSF    1F.2
05C6:  BSF    1F.3
....................  
....................    // coloca el reloj interno del micro como fuente de reloj para el mod adc 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
05C7:  BCF    1F.6
05C8:  BCF    03.5
05C9:  BSF    1F.6
05CA:  BSF    1F.7
05CB:  BSF    03.5
05CC:  BCF    1F.7
05CD:  BCF    03.5
05CE:  BSF    1F.0
....................     
....................    // coloca el puerto AN0 como entrada del modulo adc 
....................    set_adc_channel(0); 
05CF:  MOVLW  00
05D0:  MOVWF  78
05D1:  MOVF   1F,W
05D2:  ANDLW  C7
05D3:  IORWF  78,W
05D4:  MOVWF  1F
....................     
....................    // retardo para que se configure el modulo adc 
....................    delay_us(50); 
05D5:  MOVLW  53
05D6:  MOVWF  77
05D7:  DECFSZ 77,F
05D8:  GOTO   5D7
....................     
....................    // configuramos el modulo ccp en modo pwm 
....................    setup_ccp1(CCP_PWM); 
05D9:  BCF    2B.2
05DA:  MOVF   2B,W
05DB:  BSF    03.5
05DC:  MOVWF  07
05DD:  BCF    03.5
05DE:  BCF    07.2
05DF:  MOVLW  0C
05E0:  MOVWF  17
....................     
....................    // configuramos trisc.2 como salida 
....................    set_tris_d(PIN_C2); // salidas 
05E1:  MOVLW  3A
05E2:  BSF    03.5
05E3:  MOVWF  08
....................     
....................    // configuramos timer 2 con prescaler 1:16, con un periodo de 155 y un  
....................    // postcaler 1:1 
....................    setup_timer_2(T2_DIV_BY_16,155,1);    
05E4:  MOVLW  00
05E5:  MOVWF  78
05E6:  IORLW  06
05E7:  BCF    03.5
05E8:  MOVWF  12
05E9:  MOVLW  9B
05EA:  BSF    03.5
05EB:  MOVWF  12
....................    set_pwm1_duty(0); 
05EC:  BCF    03.5
05ED:  CLRF   15
....................     
....................    int porcentaje = 0; 
05EE:  CLRF   44
....................     
....................    printf("Para cambiar un control presione el boton. \n\n"); 
05EF:  MOVLW  A7
05F0:  BSF    03.6
05F1:  MOVWF  0D
05F2:  MOVLW  00
05F3:  MOVWF  0F
05F4:  BCF    03.6
05F5:  CALL   216
....................    printf("Cuando utilice el modo terminal, usar el comando: 'pwm=80'\n"); 
05F6:  MOVLW  BE
05F7:  BSF    03.6
05F8:  MOVWF  0D
05F9:  MOVLW  00
05FA:  MOVWF  0F
05FB:  BCF    03.6
05FC:  CALL   216
....................    while(TRUE) 
....................    {  
....................       recibio_comando = leer_comando(&comando);             
05FD:  CLRF   47
05FE:  MOVLW  36
05FF:  MOVWF  46
0600:  GOTO   26E
0601:  MOVF   78,W
0602:  MOVWF  43
....................        
....................       if(recibio_comando) { 
0603:  MOVF   43,F
0604:  BTFSC  03.2
0605:  GOTO   6BE
....................          int comando_correcto = separar_comando(&comando, &porcentaje_pwm); 
0606:  CLRF   47
0607:  MOVLW  36
0608:  MOVWF  46
0609:  CLRF   49
060A:  MOVLW  40
060B:  MOVWF  48
060C:  GOTO   3CE
060D:  MOVF   78,W
060E:  MOVWF  45
....................           
....................          switch( comando_correcto ){ 
060F:  MOVF   45,W
0610:  XORLW  01
0611:  BTFSC  03.2
0612:  GOTO   623
0613:  XORLW  03
0614:  BTFSC  03.2
0615:  GOTO   63B
0616:  XORLW  01
0617:  BTFSC  03.2
0618:  GOTO   653
0619:  XORLW  07
061A:  BTFSC  03.2
061B:  GOTO   66B
061C:  XORLW  01
061D:  BTFSC  03.2
061E:  GOTO   683
061F:  XORLW  03
0620:  BTFSC  03.2
0621:  GOTO   69B
0622:  GOTO   6B3
....................             case 1: 
....................                lcd_gotoxy(1,1); 
0623:  MOVLW  01
0624:  MOVWF  4A
0625:  MOVWF  4B
0626:  CALL   4C6
....................                printf(lcd_putc," Comando temperatura \n ");  
0627:  MOVLW  DC
0628:  BSF    03.6
0629:  MOVWF  0D
062A:  MOVLW  00
062B:  MOVWF  0F
062C:  BCF    03.6
062D:  CALL   504
....................                lcd_gotoxy(1,2); 
062E:  MOVLW  01
062F:  MOVWF  4A
0630:  MOVLW  02
0631:  MOVWF  4B
0632:  CALL   4C6
....................                printf(lcd_putc," Temperatura: \n "); 
0633:  MOVLW  E8
0634:  BSF    03.6
0635:  MOVWF  0D
0636:  MOVLW  00
0637:  MOVWF  0F
0638:  BCF    03.6
0639:  CALL   504
....................                break; 
063A:  GOTO   6BE
....................                 
....................             case 2: 
....................                lcd_gotoxy(1,1); 
063B:  MOVLW  01
063C:  MOVWF  4A
063D:  MOVWF  4B
063E:  CALL   4C6
....................                printf(lcd_putc," Comando pwm \n ");  
063F:  MOVLW  F1
0640:  BSF    03.6
0641:  MOVWF  0D
0642:  MOVLW  00
0643:  MOVWF  0F
0644:  BCF    03.6
0645:  CALL   504
....................                lcd_gotoxy(1,2); 
0646:  MOVLW  01
0647:  MOVWF  4A
0648:  MOVLW  02
0649:  MOVWF  4B
064A:  CALL   4C6
....................                printf(lcd_putc," Seal pwm: \n "); 
064B:  MOVLW  F9
064C:  BSF    03.6
064D:  MOVWF  0D
064E:  MOVLW  00
064F:  MOVWF  0F
0650:  BCF    03.6
0651:  GOTO   55A
....................                break; 
0652:  GOTO   6BE
....................             case 3: 
....................                lcd_gotoxy(1,1); 
0653:  MOVLW  01
0654:  MOVWF  4A
0655:  MOVWF  4B
0656:  CALL   4C6
....................                printf(lcd_putc," Comando motor on  \n ");  
0657:  MOVLW  08
0658:  BSF    03.6
0659:  MOVWF  0D
065A:  MOVLW  01
065B:  MOVWF  0F
065C:  BCF    03.6
065D:  CALL   504
....................                lcd_gotoxy(1,2); 
065E:  MOVLW  01
065F:  MOVWF  4A
0660:  MOVLW  02
0661:  MOVWF  4B
0662:  CALL   4C6
....................                printf(lcd_putc," Motores encendidos \n "); 
0663:  MOVLW  13
0664:  BSF    03.6
0665:  MOVWF  0D
0666:  MOVLW  01
0667:  MOVWF  0F
0668:  BCF    03.6
0669:  CALL   504
....................                //!               porcentaje = atol(porcentaje_pwm); 
....................                 
.................... //!               if(porcentaje > 99) {  
.................... //!                  porcentaje = 99; 
.................... //!               } 
....................                break; 
066A:  GOTO   6BE
....................             case 4: 
....................                lcd_gotoxy(1,1); 
066B:  MOVLW  01
066C:  MOVWF  4A
066D:  MOVWF  4B
066E:  CALL   4C6
....................                printf(lcd_putc," Comando motor off  \n ");  
066F:  MOVLW  1F
0670:  BSF    03.6
0671:  MOVWF  0D
0672:  MOVLW  01
0673:  MOVWF  0F
0674:  BCF    03.6
0675:  CALL   504
....................                lcd_gotoxy(1,2); 
0676:  MOVLW  01
0677:  MOVWF  4A
0678:  MOVLW  02
0679:  MOVWF  4B
067A:  CALL   4C6
....................                printf(lcd_putc," Motores apagados \n ");  
067B:  MOVLW  2B
067C:  BSF    03.6
067D:  MOVWF  0D
067E:  MOVLW  01
067F:  MOVWF  0F
0680:  BCF    03.6
0681:  CALL   504
....................                break; 
0682:  GOTO   6BE
....................                 
....................             case 5: 
....................                lcd_gotoxy(1,1); 
0683:  MOVLW  01
0684:  MOVWF  4A
0685:  MOVWF  4B
0686:  CALL   4C6
....................                printf(lcd_putc," Comando leds on  \n ");  
0687:  MOVLW  36
0688:  BSF    03.6
0689:  MOVWF  0D
068A:  MOVLW  01
068B:  MOVWF  0F
068C:  BCF    03.6
068D:  CALL   504
....................                lcd_gotoxy(1,2); 
068E:  MOVLW  01
068F:  MOVWF  4A
0690:  MOVLW  02
0691:  MOVWF  4B
0692:  CALL   4C6
....................                printf(lcd_putc," Leds encendidos \n ");  
0693:  MOVLW  41
0694:  BSF    03.6
0695:  MOVWF  0D
0696:  MOVLW  01
0697:  MOVWF  0F
0698:  BCF    03.6
0699:  CALL   504
....................                break; 
069A:  GOTO   6BE
....................                 
....................             case 6: 
....................                lcd_gotoxy(1,1); 
069B:  MOVLW  01
069C:  MOVWF  4A
069D:  MOVWF  4B
069E:  CALL   4C6
....................                printf(lcd_putc," Comando leds off  \n ");  
069F:  MOVLW  4B
06A0:  BSF    03.6
06A1:  MOVWF  0D
06A2:  MOVLW  01
06A3:  MOVWF  0F
06A4:  BCF    03.6
06A5:  CALL   504
....................                lcd_gotoxy(1,2); 
06A6:  MOVLW  01
06A7:  MOVWF  4A
06A8:  MOVLW  02
06A9:  MOVWF  4B
06AA:  CALL   4C6
....................                printf(lcd_putc," Leds apagados \n ");  
06AB:  MOVLW  56
06AC:  BSF    03.6
06AD:  MOVWF  0D
06AE:  MOVLW  01
06AF:  MOVWF  0F
06B0:  BCF    03.6
06B1:  CALL   504
....................                break; 
06B2:  GOTO   6BE
....................              
....................             default: 
....................                lcd_gotoxy(1,1); 
06B3:  MOVLW  01
06B4:  MOVWF  4A
06B5:  MOVWF  4B
06B6:  CALL   4C6
....................                printf(lcd_putc," Comando no reconocido  \n ");              
06B7:  MOVLW  5F
06B8:  BSF    03.6
06B9:  MOVWF  0D
06BA:  MOVLW  01
06BB:  MOVWF  0F
06BC:  BCF    03.6
06BD:  CALL   504
....................          } 
....................       } 
....................       delay_us(10); 
06BE:  MOVLW  10
06BF:  MOVWF  77
06C0:  DECFSZ 77,F
06C1:  GOTO   6C0
06C2:  NOP
06C3:  GOTO   5FD
....................  
....................    }                               
....................     
....................    return 0; 
06C4:  MOVLW  00
06C5:  MOVWF  78
.................... } 
....................  
06C6:  SLEEP
.................... void ajustaPWM(int16 ciclo) 
.................... { 
....................    if(ciclo>=0 && ciclo<=100) { 
....................        
....................       set_pwm1_duty((int16)(ciclo * 624 / 100)); 
....................    } else { 
....................       set_pwm1_duty(0); 
....................    } 
.................... } 
....................  
.................... int leer_comando(char* comando) { 
....................    // se revisa si se han recibido datos desde el puerto serial 
....................    if(kbhit()) { 
*
026E:  BTFSS  0C.5
026F:  GOTO   280
....................       gets(comando); 
0270:  MOVF   46,W
0271:  MOVWF  04
0272:  BCF    03.7
0273:  BTFSC  47.0
0274:  BSF    03.7
0275:  DECF   04,F
0276:  INCF   04,F
0277:  BTFSS  0C.5
0278:  GOTO   277
0279:  MOVF   1A,W
027A:  MOVWF  00
027B:  MOVLW  0D
027C:  SUBWF  00,W
027D:  BTFSS  03.2
027E:  GOTO   276
027F:  CLRF   00
....................       // printf("%s", comando); 
....................        
....................         
....................          
....................    } 
....................     
....................    return 0; // no recibio ningun comando 
0280:  MOVLW  00
0281:  MOVWF  78
0282:  BCF    0A.3
0283:  BCF    0A.4
0284:  GOTO   601 (RETURN)
.................... } 
....................  
.................... // el comando viene como "pwm=100" 
.................... int separar_comando(char* comando, char* porcentaje_pwm) { 
....................    char delim[] = "="; 
*
03CE:  MOVLW  3D
03CF:  MOVWF  4A
03D0:  CLRF   4B
....................    char copia_comando[TAM_COMANDO];  
....................    strcpy(copia_comando, comando); // Crea una copia para evitar modificar la cadena original 
03D1:  MOVF   47,W
03D2:  MOVWF  69
03D3:  MOVF   46,W
03D4:  MOVWF  68
03D5:  CLRF   67
03D6:  MOVLW  4C
03D7:  MOVWF  66
03D8:  MOVF   68,W
03D9:  MOVWF  04
03DA:  BCF    03.7
03DB:  BTFSC  69.0
03DC:  BSF    03.7
03DD:  MOVF   00,W
03DE:  MOVWF  6A
03DF:  MOVF   66,W
03E0:  MOVWF  04
03E1:  BCF    03.7
03E2:  BTFSC  67.0
03E3:  BSF    03.7
03E4:  MOVF   6A,W
03E5:  MOVWF  00
03E6:  MOVF   00,F
03E7:  BTFSC  03.2
03E8:  GOTO   3EC
03E9:  INCF   66,F
03EA:  INCF   68,F
03EB:  GOTO   3D8
....................    char *token = strtok(copia_comando, delim); 
....................     
....................    char *numero = strtok(0,delim); 
03EC:  CLRF   67
03ED:  MOVLW  4C
03EE:  MOVWF  66
03EF:  CLRF   69
03F0:  MOVLW  4A
03F1:  MOVWF  68
03F2:  CALL   285
03F3:  MOVF   79,W
03F4:  MOVWF  57
03F5:  MOVF   78,W
03F6:  MOVWF  56
03F7:  CLRF   67
03F8:  CLRF   66
03F9:  CLRF   69
03FA:  MOVLW  4A
03FB:  MOVWF  68
03FC:  CALL   285
03FD:  MOVF   79,W
03FE:  MOVWF  59
03FF:  MOVF   78,W
0400:  MOVWF  58
....................     
....................    if( token ){ 
0401:  MOVF   56,W
0402:  IORWF  57,W
0403:  BTFSC  03.2
0404:  GOTO   4C1
....................        if (strcmp(token, (void*) "temperatura") == 0) { 
0405:  CLRF   78
0406:  MOVLW  0C
0407:  MOVWF  77
0408:  MOVLW  5A
0409:  MOVWF  04
040A:  BCF    03.7
040B:  MOVF   78,W
040C:  CALL   04F
040D:  MOVWF  00
040E:  INCF   78,F
040F:  INCF   04,F
0410:  DECFSZ 77,F
0411:  GOTO   40B
0412:  MOVF   57,W
0413:  MOVWF  69
0414:  MOVF   56,W
0415:  MOVWF  68
0416:  CLRF   6B
0417:  MOVLW  5A
0418:  MOVWF  6A
0419:  CALL   38A
041A:  MOVF   78,F
041B:  BTFSS  03.2
041C:  GOTO   420
....................             return 1;  
041D:  MOVLW  01
041E:  MOVWF  78
041F:  GOTO   4C3
....................         } 
....................           
....................          if (strcmp(token, (void*) "pwm") == 0) { 
0420:  MOVLW  70
0421:  MOVWF  5A
0422:  MOVLW  77
0423:  MOVWF  5B
0424:  MOVLW  6D
0425:  MOVWF  5C
0426:  CLRF   5D
0427:  MOVF   57,W
0428:  MOVWF  69
0429:  MOVF   56,W
042A:  MOVWF  68
042B:  CLRF   6B
042C:  MOVLW  5A
042D:  MOVWF  6A
042E:  CALL   38A
042F:  MOVF   78,F
0430:  BTFSS  03.2
0431:  GOTO   455
....................             if( numero ){ 
0432:  MOVF   58,W
0433:  IORWF  59,W
0434:  BTFSC  03.2
0435:  GOTO   455
....................             strcpy(porcentaje_pwm, numero); 
0436:  MOVF   59,W
0437:  MOVWF  69
0438:  MOVF   58,W
0439:  MOVWF  68
043A:  MOVF   49,W
043B:  MOVWF  67
043C:  MOVF   48,W
043D:  MOVWF  66
043E:  MOVF   68,W
043F:  MOVWF  04
0440:  BCF    03.7
0441:  BTFSC  69.0
0442:  BSF    03.7
0443:  MOVF   00,W
0444:  MOVWF  6A
0445:  MOVF   66,W
0446:  MOVWF  04
0447:  BCF    03.7
0448:  BTFSC  67.0
0449:  BSF    03.7
044A:  MOVF   6A,W
044B:  MOVWF  00
044C:  MOVF   00,F
044D:  BTFSC  03.2
044E:  GOTO   452
044F:  INCF   66,F
0450:  INCF   68,F
0451:  GOTO   43E
....................             return 2; 
0452:  MOVLW  02
0453:  MOVWF  78
0454:  GOTO   4C3
....................             }              
....................         } 
....................          
....................         if (strcmp(token, (void*) "motor on") == 0) { 
0455:  CLRF   78
0456:  MOVLW  09
0457:  MOVWF  77
0458:  MOVLW  5A
0459:  MOVWF  04
045A:  BCF    03.7
045B:  MOVF   78,W
045C:  CALL   05F
045D:  MOVWF  00
045E:  INCF   78,F
045F:  INCF   04,F
0460:  DECFSZ 77,F
0461:  GOTO   45B
0462:  MOVF   57,W
0463:  MOVWF  69
0464:  MOVF   56,W
0465:  MOVWF  68
0466:  CLRF   6B
0467:  MOVLW  5A
0468:  MOVWF  6A
0469:  CALL   38A
046A:  MOVF   78,F
046B:  BTFSS  03.2
046C:  GOTO   470
....................             return 3;  
046D:  MOVLW  03
046E:  MOVWF  78
046F:  GOTO   4C3
....................         } 
....................          
....................          if (strcmp(token, (void*) "motor off") == 0) { 
0470:  CLRF   78
0471:  MOVLW  0A
0472:  MOVWF  77
0473:  MOVLW  5A
0474:  MOVWF  04
0475:  BCF    03.7
0476:  MOVF   78,W
0477:  CALL   06C
0478:  MOVWF  00
0479:  INCF   78,F
047A:  INCF   04,F
047B:  DECFSZ 77,F
047C:  GOTO   476
047D:  MOVF   57,W
047E:  MOVWF  69
047F:  MOVF   56,W
0480:  MOVWF  68
0481:  CLRF   6B
0482:  MOVLW  5A
0483:  MOVWF  6A
0484:  CALL   38A
0485:  MOVF   78,F
0486:  BTFSS  03.2
0487:  GOTO   48B
....................             return 4;  
0488:  MOVLW  04
0489:  MOVWF  78
048A:  GOTO   4C3
....................         } 
....................          
....................          if (strcmp(token, (void*) "leds on") == 0) { 
048B:  CLRF   78
048C:  MOVLW  08
048D:  MOVWF  77
048E:  MOVLW  5A
048F:  MOVWF  04
0490:  BCF    03.7
0491:  MOVF   78,W
0492:  CALL   07A
0493:  MOVWF  00
0494:  INCF   78,F
0495:  INCF   04,F
0496:  DECFSZ 77,F
0497:  GOTO   491
0498:  MOVF   57,W
0499:  MOVWF  69
049A:  MOVF   56,W
049B:  MOVWF  68
049C:  CLRF   6B
049D:  MOVLW  5A
049E:  MOVWF  6A
049F:  CALL   38A
04A0:  MOVF   78,F
04A1:  BTFSS  03.2
04A2:  GOTO   4A6
....................             return 5;  
04A3:  MOVLW  05
04A4:  MOVWF  78
04A5:  GOTO   4C3
....................         } 
....................          
....................          if (strcmp(token, (void*) "leds off") == 0) { 
04A6:  CLRF   78
04A7:  MOVLW  09
04A8:  MOVWF  77
04A9:  MOVLW  5A
04AA:  MOVWF  04
04AB:  BCF    03.7
04AC:  MOVF   78,W
04AD:  CALL   086
04AE:  MOVWF  00
04AF:  INCF   78,F
04B0:  INCF   04,F
04B1:  DECFSZ 77,F
04B2:  GOTO   4AC
04B3:  MOVF   57,W
04B4:  MOVWF  69
04B5:  MOVF   56,W
04B6:  MOVWF  68
04B7:  CLRF   6B
04B8:  MOVLW  5A
04B9:  MOVWF  6A
04BA:  CALL   38A
04BB:  MOVF   78,F
04BC:  BTFSS  03.2
04BD:  GOTO   4C1
....................             return 6;  
04BE:  MOVLW  06
04BF:  MOVWF  78
04C0:  GOTO   4C3
....................         } 
....................    } 
....................     
....................     
....................    return 0; 
04C1:  MOVLW  00
04C2:  MOVWF  78
04C3:  BCF    0A.3
04C4:  BCF    0A.4
04C5:  GOTO   60D (RETURN)
.................... } 

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
